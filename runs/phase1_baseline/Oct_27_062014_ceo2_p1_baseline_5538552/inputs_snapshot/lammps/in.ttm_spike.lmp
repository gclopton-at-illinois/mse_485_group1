# --- TTM spike stage: NVE on interior + USER-TTM electrons (Phase 1) ---
print "=== TTM spike stage: NVE (interior) + USER-TTM electron field ===" screen yes

# Interior = all atoms minus the x/y rim sponge from rim_langevin.in
group        interior subtract all rim

# For logging only (TEF is passed as -var TEF by run_nominal.sh)
variable     r0_A equal ${R0}*10.0
print        "TTM source via infile: r0=${R0} nm (=${r0_A} A) ; Te.in=${TEF}" screen yes

# Lattice integrator
fix          f_nve   interior nve

# --- USER-TTM (Phase-1 simple coefficients; refine later if desired) ---
variable     CE0     equal 1.0
variable     RHOE0   equal 1.0
variable     KE0     equal 1.0
variable     GP      equal 5.0
variable     GS      equal 0.0
variable     V0      equal 1.0

# Grid sizes for ttm/grid arguments (approx. 1 Ã… spacing)
variable     iNX     equal ceil(lx/1.0)
variable     iNY     equal ceil(ly/1.0)
variable     iNZ     equal ceil(lz/1.0)

# Read the precomputed Te field from the runner
fix          f_ttm   interior ttm/grid 12345 ${CE0} ${RHOE0} ${KE0} ${GP} ${GS} ${V0} ${iNX} ${iNY} ${iNZ} infile ${TEF}

# Initialize computes/thermo after adding fixes
run          0 post no

# ---------------- Phase-1 energy logging for energy_balance.py ----------------
# f_f_ttm[1] = total electron energy [eV]; lattice energy use ET=etotal (declared in in.main.lmp)
variable     Ee   equal f_f_ttm[1]
# Rim thermostat cumulative work (requires 'fix f_rim ... tally yes' in rim_langevin.in):
variable     ERIM equal f_f_rim

# Single compact TSV in post/ with the three columns needed by energy_balance.py
# Uses cadence from in.main.lmp: variable th_every == ${THERMO_EVERY}
fix          f_p1ener all print ${th_every} "${s} ${Ee} ${ET} ${ERIM}" file ${OUTDIR}/post/thermo_energy.tsv screen no title "step E_electron_eV E_lattice_eV E_langevin_eV_cum"
# ------------------------------------------------------------------------------

# Spike length: NSTEPS - neq  (neq is defined in in.main.lmp)
variable     nspike equal ${NSTEPS}-${neq}
print        "Spike steps (nspike) = ${nspike}" screen yes

# Dump during the spike (for analyses)
dump         dspike all custom 100 ${OUTDIR}/dumps/atoms.spike.*.lammpstrj id type x y z vx vy vz q
                                   # ^^^ fix: 'vy' not 'virtually'
dump_modify  dspike sort id

# Run the spike
run          ${nspike}
undump       dspike

# Cleanup
unfix        f_p1ener
unfix        f_nve
unfix        f_ttm

print        "=== Spike complete; end of Phase 1 baseline shot ===" screen yes
